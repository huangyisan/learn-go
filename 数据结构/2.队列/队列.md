## 队列
1. 队列是一个有序的列表, 可以使用**数组**或者**链表**来实现.
2. 遵循**先入先出**的原则.

## 数组模拟队列(单一方向,不可循环)
1. 定义两个标记, head和tail.
2. head表示队列头部(但不包含队首元素, head随着元素的弹出而改变), tail表示队列尾部(tail随着元素的推入而改变).
3. 当tail等于head, 此时表示队列为空.
4. 当tail等于队列容量-1, 此时表示队列已满(之所以-1,是因为tail是从-1开始).
5. tail从-1开始,每次塞入一个数据, 先tail+1, 然后塞入
6. head从-1开始,每次弹出一个数据, 先head+1, 然后弹出

## 数组模拟队列(循环方式, 可以充分利用数组)
1. 环形队列克服了单向队列的问题，只要数据被取出，就可以一直被填充新数据。
2. 环形队列其实也是数组实现的，只是当数据填入队尾后，使用**取模**的方式，重新将tail移动至队头。
3. 一般情况下，比如单向队列，填充数据，队尾+1，也就是tail+1, 当队列非空的时候，tail的角标一定大于队头head的角标，但环形数组不同，因为tail会产生移动到队头的情况，所以存在head的角标大于tail角标的情况。**但无论如何，tail和head相等的情况有且只会产生两次，一次是空队列的时候，还有一次是队列满的时候**。
4. 正因为存在当tail和head相等的时候有两种不确定性，**所以我们可以在塞入数据后，限制tail追赶且跟head平齐，预留一个空位的方式，当tail+1除以队列长度，如果等于head，则表示队列满，这种情况，队列的可用度为队列长度-1**。
5. **那么tail和head相等的情况只会发生在队列为空的时候，此时的相等是tail被head追赶并平齐了。**
6. tail和head的起始位置角标都为0。
7. 如果要计算当前队列长度，如果是单向队列，那么只需要获取head至tail位置的内容即可，但环形队列存在重置队头的情况，队列长度为(tail+队列长度-head) % 队列长度。
8. 为什么用这个长度算法公式？因为存在tail重置队头的情况，直接tail加上队列长度则假定每次都重置队头，最后除以队列长度，则是获取真实长度。